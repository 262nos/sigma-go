package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"path/filepath"
	"reflect"
	"text/template"

	"github.com/bradleyjkemp/sigma-go"
	"github.com/sanity-io/litter"
	"gopkg.in/yaml.v3"
)

var (
	fRecursive = flag.Bool("recursive", true, "whether to compile directories recursively")
)

func main() {
	flag.Parse()

	paths := flag.Args()
	if len(paths) == 0 {
		paths = []string{"."}
	}

	for _, path := range paths {
		if err := run(path, *fRecursive); err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
	}
}

var litterConfig = litter.Options{
	// Work around bug: https://github.com/sanity-io/litter/issues/33
	FieldFilter: func(field reflect.StructField, value reflect.Value) bool {
		switch value.Kind() {
		case reflect.Slice:
			return value.Len() != 0
		default:
			return true
		}
	},
}

func run(root string, recursive bool) error {
	directories := map[string]struct{}{}
	rulesByDirectory := map[string][]string{}
	configByDirectory := map[string][]string{}

	// Collect all the rules under this root
	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if info.IsDir() {
			if path != root && !recursive {
				return filepath.SkipDir
			}
			return nil
		}

		if filepath.Ext(path) != ".yaml" && filepath.Ext(path) != ".yml" {
			return nil
		}

		contents, err := ioutil.ReadFile(path)
		if err != nil {
			return fmt.Errorf("error reading %s: %w", path, err)
		}

		var fileType fileType
		yaml.Unmarshal(contents, &fileType)

		switch fileType {
		case rule:
			ruleFile, err := sigma.ParseRule(contents)
			if err != nil {
				return fmt.Errorf("error parsing %s: %w", path, err)
			}

			dir := filepath.Dir(path)
			directories[dir] = struct{}{}
			rulesByDirectory[dir] = append(rulesByDirectory[dir], litterConfig.Sdump(ruleFile))

		case config:
			configFile, err := sigma.ParseConfig(contents)
			if err != nil {
				return fmt.Errorf("error parsing %s: %w", path, err)
			}

			dir := filepath.Dir(path)
			directories[dir] = struct{}{}
			configByDirectory[dir] = append(configByDirectory[dir], litterConfig.Sdump(configFile))
		}

		return nil
	})
	if err != nil {
		return err
	}

	// For each directory containing Sigma rules, write a sigma.go file containing all the rules
	for dir := range directories {
		_, packageName := filepath.Split(dir)
		params := map[string]interface{}{
			"PackageName": packageName,
			"Rules":       rulesByDirectory[dir],
			"Configs":     configByDirectory[dir],
		}
		rendered := &bytes.Buffer{}
		if err := registryTmpl.Execute(rendered, params); err != nil {
			return err
		}
		formattedBytes, err := format.Source(rendered.Bytes())
		if err != nil {
			return err
		}
		if err := ioutil.WriteFile(filepath.Join(dir, "sigma.go"), formattedBytes, 0644); err != nil {
			return err
		}
	}

	return nil
}

var registryTmpl = template.Must(template.New("registry").Parse(`// Code generated by github.com/bradleyjkemp/sigma-go/sigmac DO NOT EDIT.
package {{.PackageName}}

import (
	sigma "github.com/bradleyjkemp/sigma-go"

	"sort"
)

var Rules = map[string]sigma.Rule{}

var Configs []sigma.Config

func registerRule(rule sigma.Rule) {
	id := rule.ID
	if id == "" {
		id = "MISSING_ID_" + rule.Title
	}

	if _, ok := Rules[id]; ok {
		panic("rule with id " + id + " already registered")
	}
	Rules[id] = rule
}

func registerConfig(config sigma.Config) {
	Configs = append(Configs, config)
	sort.Slice(Configs, func(i, j int) bool {
		return Configs[i].Order < Configs[j].Order
	})
}

func init() {
{{- range .Rules}}
	registerRule({{ . }})
{{end}}
{{- range .Configs}}
	registerConfig({{ . }})
{{end}}
}
`))
